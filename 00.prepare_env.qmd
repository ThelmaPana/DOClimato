---
title: "Prepare environmental data from woa and others"
subtitle: "Read raw env data, clean it and format it nicely."
author: "Thelma Panaïotis, Laetitia Drago & Jean-Olivier Irisson"
format:
  html:
    toc: true
    embed-resources: true
editor: visual
execute:
  cache: true
  warning: false
---

```{r set_up}
#| output: false
#| warning: false
#| cache: false
source("utils.R")
```

## Predictors overview

### List

Aim to predict DOC in 3 layers:

-   surface: 0-10 m

-   mesopelagic: 200 - 1000 m

-   bathypelagic: \> 1000 m

The table below details the predictors used for each layer.

+-------------+------------+-----------+-------------+-------------+------------------------+
| What        | From where | Timescale | Depth range | Layers      | Predictor for          |
+=============+============+===========+=============+=============+========================+
| Temperature | WOA        | Seasonal  | 0-5500      | -   surface | -   surface/meso/bathy |
|             |            |           |             |             |                        |
|             |            |           |             | -   meso    | -   meso/bathy         |
|             |            |           |             |             |                        |
|             |            |           |             | -   bathy   | -   bathy              |
+-------------+------------+-----------+-------------+-------------+------------------------+
| Salinity    | WOA        | Seasonal  | 0-5500      | -   surface | -   surface/meso/bathy |
|             |            |           |             |             |                        |
|             |            |           |             | -   meso    | -   meso/bathy         |
|             |            |           |             |             |                        |
|             |            |           |             | -   bathy   | -   bathy              |
+-------------+------------+-----------+-------------+-------------+------------------------+
| Density     | WOA        | Seasonal  | 0-5500?     | -   surface | -   surface/meso/bathy |
|             |            |           |             |             |                        |
|             |            |           |             | -   meso    | -   meso/bathy         |
|             |            |           |             |             |                        |
|             |            |           |             | -   bathy   | -   bathy              |
+-------------+------------+-----------+-------------+-------------+------------------------+
| Oxygen      | WOA        | Seasonal  | 0-1500      | -   surface | -   surface/meso/bathy |
|             |            |           |             |             |                        |
|             |            |           |             | -   meso    | -   meso/bathy         |
|             |            |           |             |             |                        |
|             |            |           |             | -   bathy   | -   bathy              |
+-------------+------------+-----------+-------------+-------------+------------------------+
| AOU         | WOA        | Seasonal  | 0-1500?     | -   surface | -   surface/meso/bathy |
|             |            |           |             |             |                        |
|             |            |           |             | -   meso    | -   meso/bathy         |
|             |            |           |             |             |                        |
|             |            |           |             | -   bathy   | -   bathy              |
+-------------+------------+-----------+-------------+-------------+------------------------+
| Silicate    | WOA        | Seasonal  | 0-800       | -   surface | -   surface/meso/bathy |
|             |            |           |             |             |                        |
|             |            |           |             | -   meso    | -   meso/bathy         |
+-------------+------------+-----------+-------------+-------------+------------------------+
| Phosphate   | WOA        | Seasonal  | 0-800       | -   surface | -   surface/meso/bathy |
|             |            |           |             |             |                        |
|             |            |           |             | -   meso    | -   meso/bathy         |
+-------------+------------+-----------+-------------+-------------+------------------------+
| Nitrate     | WOA        | Seasonal  | 0-800       | -   surface | -   surface/meso/bathy |
|             |            |           |             |             |                        |
|             |            |           |             | -   meso    | -   meso/bathy         |
+-------------+------------+-----------+-------------+-------------+------------------------+
| MLD         | WOA        | Seasonal  | Depth value |             | surface/meso/bathy     |
+-------------+------------+-----------+-------------+-------------+------------------------+
| Thermocline | To compute | Seasonal  | Depth value |             | surface/meso/bathy     |
+-------------+------------+-----------+-------------+-------------+------------------------+
| Pycnocline  | To compute | Seasonal  | Depth value |             | surface/meso/bathy     |
+-------------+------------+-----------+-------------+-------------+------------------------+
| N-cline     | To compute | Seasonal  | Depth value |             | surface/meso/bathy     |
+-------------+------------+-----------+-------------+-------------+------------------------+
| P-cline     | To compute | Seasonal  | Depth value |             | surface/meso/bathy     |
+-------------+------------+-----------+-------------+-------------+------------------------+
| S-cline     | To compute | Seasonal  | Depth value |             | surface/meso/bathy     |
+-------------+------------+-----------+-------------+-------------+------------------------+
| Z~eu~       | Cael       | Monthly   | Depth value |             | surface/meso/bathy     |
+-------------+------------+-----------+-------------+-------------+------------------------+
| NPP         | Cael       | Monthly   | Surface     |             | surface/meso/bathy     |
+-------------+------------+-----------+-------------+-------------+------------------------+
| BBP         | Cael       | Monthly   | Surface     |             | surface/meso/bathy     |
+-------------+------------+-----------+-------------+-------------+------------------------+
| Fmicro      | Cael       | Monthly   | Surface     |             | surface/meso/bathy     |
+-------------+------------+-----------+-------------+-------------+------------------------+
| log(chl)    | Cael       | Monthly   | Surface     |             | surface/meso/bathy     |
+-------------+------------+-----------+-------------+-------------+------------------------+
| PIC         | Cael       | Monthly   | Surface     |             | surface/meso/bathy     |
+-------------+------------+-----------+-------------+-------------+------------------------+
| φ PSD slope | Cael       | Monthly   | Surface     |             | surface/meso/bathy     |
+-------------+------------+-----------+-------------+-------------+------------------------+
| Irradiance  | Cael       | Monthly   | Surface     |             | surface/meso/bathy     |
+-------------+------------+-----------+-------------+-------------+------------------------+

: Predictors set.

::: callout-note
## Differences from woa

No more alkalinity and DIC. This is probably not important as these were not strong predictors in preliminary analyses.
:::

### Processing

We need:

-   seasonal + annual values at the surface (because surface data are also used to predict meso and bathy, with annual timescale)

-   annual values in the meso and bathy

## WOA

### Download

Perform only if necessary.

```{r download_woa}
if (download_woa){
  # define all combinations of variables to download
  df <- read_csv(
    "var,abbrv,period
    temperature,t,A5B7
    salinity,s,A5B7
    density,I,A5B7
    mld,M02,A5B7
    AOU,A,all
    silicate,i,all
    phosphate,p,all
    nitrate,n,all
    oxygen,o,all
  ", show_col_types = FALSE)
  month <- sprintf("%02i",13:16) # seasons
  combi <- crossing(df, month)

  # define download URLs
  urls <- str_glue("https://data.nodc.noaa.gov/thredds/fileServer/ncei/woa/{var}/{period}/1.00/woa18_{period}_{abbrv}{month}_01.nc", .envir = combi)

  # and download files
  lapply(urls, function(url) {
    dest <- file.path(woa_dir, basename(url))
    if (!file.exists(dest)) { # if not previously downloaded
      message(basename(url))
      download.file(url, destfile = dest)
      Sys.sleep(10)
    }

  })
  message("Done downloading WOA data")

  # create links to the downloaded files with easier names
  ok <- file.symlink(
    from = str_glue("{woa_dir}/woa18_{period}_{abbrv}{month}_01.nc", .envir = combi),
    to = file.path(woa_loc, str_glue("{var}_{month}.nc", .envir = mutate(combi, month = as.numeric(month))))
  )
  all(ok)
}
```

### Read

```{r read_woa}
# List WOA variables
vars <- c("temperature", "salinity", "density", "mld", "oxygen", "aou", "silicate", "phosphate", "nitrate")

# Open one file to get all coordinates (lon, lat, depth)
nc <- nc_open(file.path(woa_loc, "temperature_13.nc"))
lon <- ncvar_get(nc, "lon")
lat <- ncvar_get(nc, "lat")
depth <- ncvar_get(nc, "depth")
# Get indexes of relevant depth
#depth_idx <- which(depth <= max_depth_woa)
# Limit depth to chosen max depth
#depth <- ncvar_get(nc, "depth", count = max(depth_idx))
# Number of depth values
depth_count <- length(depth)
# Close the file
nc_close(nc)


# Read all files in parallel
woa <- pbmclapply(vars, function(var) {
    # prepare storage for one variable at n depths for 4 seasons
    block <- array(NA, c(360, 180, depth_count, 4))

  for (seas in 1:4) {
    # define the file to read
    file <- str_c(woa_loc, "/", var, "_", seas + 12, ".nc")
    # open the file and read the data in it
    nc <- nc_open(file)
    # get depth count (differs between variables)
    depth_count <- length(ncvar_get(nc, "depth"))

    block[,,1:depth_count,seas] <- ncvar_get(nc, varid=names(nc$var)[6], count = c(360, 180, depth_count, 1))
    #block[,,,month] <- ncvar_get(nc, varid=names(nc$var)[6])
    nc_close(nc)
  }
  return(block)
}, mc.cores = min(length(vars), n_cores))

# Add variable names
names(woa) <- vars
str(woa)
```

Plot surface values for winter.

```{r plot_surf}
image.plot(woa$temperature[,,1,1], col = col_temp, main = "Temperature")
image.plot(woa$salinity[,,1,1], col = col_sal, main = "Salinity")
image.plot(woa$density[,,1,1], col = col_dens, main = "Density")
image.plot(woa$mld[,,1,1], col = col_depth, main = "MLD")
image.plot(woa$oxygen[,,1,1], col = col_oxy, main = "Oxygen")
image.plot(woa$aou[,,1,1], col = col_aou, main = "AOU")
image.plot(woa$nitrate[,,1,1], col = col_nit, main = "Nitrate")
image.plot(woa$phosphate[,,1,1], col = col_phos, main = "Phosphate")
image.plot(woa$silicate[,,1,1], col = col_sil, main = "Silicate")
```

### Compute clines

#### Thermocline

```{r thermo}
thermo <- pbmclapply(1:4, function(m) { # in parallel
  apply(woa$temperature[,,,m], c(1,2), function(temp) {
    # check number of available data points
    ok <- !is.na(temp)
    if (sum(ok) > 3) {
      # sequence of regular depth for interpolation
      depths_i <- seq(0, max_depth_woa, by = 5) 
      # interpolate temperature on 5 m steps
      temp_i <- interpolate(depth[ok], temp[ok], depths_i, method = "spline", extrapolate = FALSE)
      # compute thermocline depth
      ok <- !is.na(temp_i)
      pyc <- clined(temp_i[ok], depths_i[ok], n.smooth = 2, k = 4)
    } else {
      pyc <- NA
    }
    return(pyc)
  })
}, mc.cores = n_cores)  # looooong, even in parallel
walk(thermo, image.plot, col = col_depth)

# smooth the result to avoid local artefacts
thermo <- lapply(thermo, function(x) {
  xs <- image.smooth(x, theta = 1)$z
  return(xs)
})
walk(thermo, image.plot, col = col_depth)

# combine all months into a matrix
thermo <- do.call(abind, list(thermo, along = 3))
```

#### Pycnocline

For this, we use data down to `r max_depth_woa` metres.

```{r pycno}
pycno <- pbmclapply(1:4, function(m) { # in parallel
  apply(woa$density[,,,m], c(1,2), function(dens) {
    # check number of available data points
    ok <- !is.na(dens)
    if (sum(ok) > 3) {
      # sequence of regular depth for interpolation
      depths_i <- seq(0, max_depth_woa, by = 5) 
      # interpolate density on 5 m steps
      dens_i <- interpolate(depth[ok], dens[ok], depths_i, method = "spline", extrapolate = FALSE)
      # compute pycnocline depth
      ok <- !is.na(dens_i)
      pyc <- clined(dens_i[ok], depths_i[ok], n.smooth = 2, k = 4)
    } else {
      pyc <- NA
    }
    return(pyc)
  })
}, mc.cores = n_cores)  # looooong, even in parallel
walk(pycno, image.plot, col = col_depth)

# smooth the result to avoid local artefacts
pycno <- lapply(pycno, function(x) {
  xs <- image.smooth(x, theta = 1)$z
  return(xs)
})
walk(pycno, image.plot, col = col_depth)

# combine all months into a matrix
pycno <- do.call(abind, list(pycno, along = 3))
```

#### Nutriclines

Let’s now compute clines for nitrates, phosphates and silicates.

##### Nitrate

```{r nitracline}
n_cline <- pbmclapply(1:4, function(m) { # in parallel
  apply(woa$nitrate[,,,m], c(1,2), function(nit) {
    # check number of available data points
    ok <- !is.na(nit)
    if (sum(ok) > 3) {
      # sequence of regular depth for interpolation
      depths_i <- seq(0, max_depth_woa, by = 5) 
      # interpolate nitrate on 5 m steps
      nit_i <- interpolate(depth[ok], nit[ok], depths_i, method = "spline", extrapolate = FALSE)
      # compute nitracline depth
      ok <- !is.na(nit_i)
      pyc <- clined(nit_i[ok], depths_i[ok], n.smooth = 2, k = 4)
    } else {
      pyc <- NA
    }
    return(pyc)
  })
}, mc.cores=n_cores)  # looooong, even in parallel
walk(n_cline, image.plot, col = col_depth)

# smooth the result to avoid local artefacts
n_cline <- lapply(n_cline, function(x) {
  xs <- image.smooth(x, theta = 1)$z
  return(xs)
})
walk(n_cline, image.plot, col = col_depth)

# combine all months into a matrix
n_cline <- do.call(abind, list(n_cline, along = 3))
```

##### Phosphate

```{r phosphacline}
p_cline <- pbmclapply(1:4, function(m) { # in parallel
  apply(woa$phosphate[,,,m], c(1,2), function(phos) {
    # check number of available data points
    ok <- !is.na(phos)
    if (sum(ok) > 3) {
      # sequence of regular depth for interpolation
      depths_i <- seq(0, max_depth_woa, by = 5) 
      # interpolate phosphate on 5 m steps
      phos_i <- interpolate(depth[ok], phos[ok], depths_i, method = "spline", extrapolate = FALSE)
      # compute phosphacline depth
      ok <- !is.na(phos_i)
      pyc <- clined(phos_i[ok], depths_i[ok], n.smooth = 2, k = 4)
    } else {
      pyc <- NA
    }
    return(pyc)
  })
}, mc.cores=n_cores)  # looooong, even in parallel
walk(p_cline, image.plot, col = col_depth)

# smooth the result to avoid local artefacts
p_cline <- lapply(p_cline, function(x) {
  xs <- image.smooth(x, theta = 1)$z
  return(xs)
})
walk(p_cline, image.plot, col = col_depth)

# combine all months into a matrix
p_cline <- do.call(abind, list(p_cline, along = 3))
```

##### Silicate

```{r silicacline}
s_cline <- pbmclapply(1:4, function(m) { # in parallel
  apply(woa$silicate[,,,m], c(1,2), function(sil) {
    # check number of available data points
    ok <- !is.na(sil)
    if (sum(ok) > 3) {
      # sequence of regular depth for interpolation
      depths_i <- seq(0, max_depth_woa, by = 5) 
      # interpolate silicate on 5 m steps
      sil_i <- interpolate(depth[ok], sil[ok], depths_i, method = "spline", extrapolate = FALSE)
      # compute phosphacline depth
      ok <- !is.na(sil_i)
      pyc <- clined(sil_i[ok], depths_i[ok], n.smooth = 2, k = 4)
    } else {
      pyc <- NA
    }
    return(pyc)
  })
}, mc.cores=n_cores)  # looooong, even in parallel
walk(s_cline, image.plot, col = col_depth)

# smooth the result to avoid local artefacts
s_cline <- lapply(s_cline, function(x) {
  xs <- image.smooth(x, theta = 1)$z
  return(xs)
})
walk(s_cline, image.plot, col = col_depth)

# combine all months into a matrix
s_cline <- do.call(abind, list(s_cline, along = 3))
```

### Average over surface layer

For each variable, compute the average in the surface layer, i.e. from `r min(depth)` to `r layer_bottom` m.

```{r avg_surf}
env <- mclapply(names(woa), function(var) {
  message(var)

  # extract variable
  X <- woa[[var]]

  # prepare storage
  res <- array(NA, dim(X)[-3])

  # for each pixel of each month
  for (i in seq(along = lon)) {
    for (j in seq(along = lat)) {
        # compute average if 2/3 of data is present
        keep <- X[i, j, depth <= layer_bottom]
        if (percent_na(keep) <= 1/3) {
          res[i, j] <- mean(keep, na.rm=TRUE)
         # otherwise just leave the NA value
      }
    }
  }
  return(res)
}, mc.cores = min(length(vars), n_cores))

# Add variable names
names(env) <- names(woa)
```

## MLD Argo Mixed Layers

Let’s try data from Argo Mixed Layers: <http://mixedlayer.ucsd.edu/>.

This data uses the same grid as WOA, we can combine them together.

```{r read_mld_argo}
# Open one file to get all coordinates (lon, lat, depth)
nc <- nc_open("data/raw/mld/Argo_mixedlayers_monthlyclim_04142022.nc")

# Get lon and lat
lon_arg <- ncvar_get(nc, "lon")
lat_arg <- ncvar_get(nc, "lat")

# Get MLD values
mld_argo <- ncvar_get(nc, "mld_da_mean")

# Close the file
nc_close(nc)

# Reorder dimensions
mld_argo <- aperm(mld_argo, c(2,3,1))

# Compute yearly from monthly
mld_argo <- apply(mld_argo, c(1,2), mean, na.rm = TRUE)

# Smooth
#mld_argo <- image.smooth(mld_argo, theta = 1)$z

# Plot
image.plot(mld_argo, col = col_depth)
```

This is better, we will clean inland data below.

## Various climatologies

### Misc

Easy one: read the `.mat` file, reshape `lon` vs `lat` and reverse `lat`. The grid is already 1°×1°×12 months.

::: {.callout-warning icon="false"}
Check grid definition
:::

```{r clims_cael}
npp <- read_clim("data/raw/clim4cael.mat", "cafes")
image(npp, col = col_npp, main = "NPP (cafe)")

z_eu <- read_clim("data/raw/clim4cael.mat", "z.eu")
image(z_eu, col = col_depth, main = "Euphotic depth")

bbp <- read_clim("data/raw/clim4cael.mat", "bbp")
image(bbp, col = col_bbp, main = "BBP")

fmicro <- read_clim("data/raw/clim4cael.mat", "fmicro")
image(fmicro, col = col_fmicro, main = "Fmicro")

log_chl <- read_clim("data/raw/clim4cael.mat", "logChl")
image(log_chl, col = col_chl, main = "log(Chl)")

pic <- read_clim("data/raw/picpoc.mat", "pic")
image(pic, col = col_pic, main = "PIC")

#poc <- read_clim("data/raw/picpoc.mat", "poc")
#image(poc, col = col_poc, main = "POC")

psd <- read_clim("data/raw/PSD_slope.mat", "Xi")
image(psd, col = col_psd, main = "Phyto PSD slope")
```

### Irradiance data

Climatology data in 12 netcdf files. Raw resolution is very high and needs to be downgraded to a 1°×1° grid.

Let’s start by just reading 1 file to get the dimensions of the grid.

```{r read_1_par}
# Open one file to get all coordinates (lon, lat)
nc <- nc_open("data/raw/modis/AQUA_MODIS.20020701_20210731.L3m.MC.PAR.par.9km.nc")
lon_par <- ncvar_get(nc, "lon")
lat_par <- ncvar_get(nc, "lat")
lat_par <- rev(lat_par) # lat will need to be reversed
nc_close(nc)
```

Now let’s read all files.

```{r read_all_par}
# List par files
par_files <- list.files("data/raw/modis", full.names = TRUE, pattern = ".nc")

# Initiate empty storage for PAR
par <- array(NA, c(length(lon_par), length(lat_par), 12))

# Loop over months
for(m in 1:12){
  # open nc file
  nc <- nc_open(par_files[m])
  # read par values for a given month
  par_m <- ncvar_get(nc, "par")
  # reorder latitudes
  par[,,m] <- par_m[, ncol(par_m):1]
  # close file
  nc_close(nc)
}

# From monthly to yearly, parallel on longitude
par <- mclapply(1:dim(par)[1], function(l){
  par_l <- par[l,,]
  apply(par_l, 1, mean, na.rm = TRUE)
}, mc.cores = n_cores)

par <- do.call(rbind, par)
```

PAR values are stored in a `r dim(par)[1]` by `r dim(par)[2]` by `r dim(par)[3]`array. To downgrade the grid, we first need to convert this data to a dataframe. Let’s process in parallel by month. For each month, floor `lon` and `lat` to 1° and add 0.5 to get the center of every pixel of the 1°×1° grid, then average PAR value per grid cell.

```{r downgrade_par}
dimnames(par) <- list(lon_par, lat_par)
# melt to dataframe
df_par <- reshape2::melt(par) %>%
  as_tibble() %>%
  rename(lon = Var1, lat = Var2, par = value)
  
# Round lon and lat to 1 degree and average per grid cell
df_par <- df_par %>%
  mutate(
    lon = roundp(lon, precision = 1, f = floor) + 0.5,
    lat = roundp(lat, precision = 1, f = floor) + 0.5
  ) %>%
  group_by(lon, lat) %>%
  summarise(par = mean(par, na.rm = TRUE)) %>%
  ungroup()

# Plot map
ggmap(df_par, "par", type = "raster")
```

## Combine all env variables

Let’s combine array formatted env variables together, i.e. all variables except for PAR data.

```{r combine}
# Pycnocline and MLD
env$pyc <- pyc
env$mld <- mld
env$mld_argo <- mld_argo

# Nutriclines
env$n_cline <- n_cline
env$p_cline <- p_cline
env$s_cline <- s_cline

# Other climatologies
env$z_eu    <- z_eu
env$npp     <- npp
env$bbp    <- bbp
env$fmicro  <- fmicro
env$log_chl <- log_chl
env$pic     <- pic
env$psd     <- psd


# Clean dimnames
dimnames(env$pyc)      <- NULL
dimnames(env$mld)      <- NULL
dimnames(env$mld_argo) <- NULL
dimnames(env$n_cline)  <- NULL
dimnames(env$p_cline)  <- NULL
dimnames(env$s_cline)  <- NULL
dimnames(env$z_eu)     <- NULL
dimnames(env$npp)      <- NULL
dimnames(env$bbp)      <- NULL
dimnames(env$fmicro)   <- NULL
dimnames(env$log_chl)  <- NULL
dimnames(env$pic)      <- NULL
dimnames(env$psd)      <- NULL
```

## Convert to dataframe

```{r to_df}
# unroll each matrix
env_v <- lapply(env, function(e) { as.vector(e) })
# combine as columns
df_env <- do.call(cbind, env_v) %>% as.data.frame() %>% setNames(names(env_v))

# add coordinates (NB: shorter elements are recycled automatically)
df_env$lon <- lon
df_env$lat <- rep(lat, each=length(lon))
```

Then join with PAR data.

```{r join_par}
df_env <- df_env %>% left_join(df_par, by = join_by(lon, lat))
```

Let’s do a quick plot to check everything is fine.

```{r map_temp}
ggmap(df_env, "temperature", type = "raster")
```

## Remove internal seas, lakes and land

```{r inland}
# determine which points are in land
lons <- df_env$lon
lats <- df_env$lat
inland <- sp::point.in.polygon(lons, lats, coast$lon, coast$lat) == 1
ggplot(df_env) +
  geom_raster(aes(x = lon, y = lat, fill = inland)) +
  scale_fill_viridis_d() +
  scale_x_continuous(expand = c(0,0)) + scale_y_continuous(expand = c(0,0)) +
  coord_quickmap()

# remove South Pole
inland[lats < -85] <- TRUE

# remove Black Sea too
inland[between(lons, 20, 50) & between(lats, 41, 50)] <- TRUE

# remove Baltic Sea too
inland[between(lons, 12, 30) & between(lats, 52, 66)] <- TRUE

ggplot(df_env) +
  geom_raster(aes(x = lon, y = lat, fill = inland)) +
  scale_fill_viridis_d() +
  scale_x_continuous(expand = c(0,0)) + scale_y_continuous(expand = c(0,0)) +
  coord_quickmap()

# blankout points in land
df_env[inland, !names(df_env) %in% c("lon", "lat")] <- NA
# NB: this works because `inland` gets automatically repeated for everymonth

# Convert to tibble and reorder columns
df_env <- df_env %>% as_tibble() %>% select(lon, lat, everything())
```

Plot a few maps without land to check.

```{r maps_check}
ggmap(df_env, "temperature", type = "raster", land = FALSE)
ggmap(df_env, "par", type = "raster", land = FALSE)
ggmap(df_env, "pyc", type = "raster", land = FALSE)
ggmap(df_env, "mld_argo", type = "raster", land = FALSE)
```

Seems all good!

## Save environmental data

```{r save}
save(df_env, file = "data/00.all_env.Rdata")
```

## Plot all maps

```{r plot_all}
# Names of env variables
var_names <- df_env %>% select(-c(lon, lat)) %>% colnames()

plot_list <- list()
for (i in 1:length(var_names)){plot_list[[i]] <- ggmap(df_env, var_names[i], type = "raster")}

plot_list

```
